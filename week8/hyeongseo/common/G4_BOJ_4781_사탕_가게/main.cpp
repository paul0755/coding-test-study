// https://www.acmicpc.net/problem/4781

// 분류 : DP, 배낭 문제

/*
풀이 생각
- 문제 읽고 딱 봐도 배낭 문제여서 dp[i][j] : i 사탕까지 봤을 때 j만큼 돈 썼을 때 최대 칼로리 라고 생각함
- n <= 5000 & m <= 100.00 이어서 시간복잡도 가능하다고 생각함
- 돈이 부동 소수점 형태여서 map 쓸려고 했는데 너무 복잡해짐
- 근데 * 100으로 하면 0.01 ~ 100.00 => 1 ~ 10000이어서 이 방법으로 진행함

------------------------------------------

첫 시도 : 실패
- dp[5001][10001] => segmentation Fault 뜸
- 5001 * 10001 이어서 크기가 너무 커서 그런가봄
- 전역으로 할당하면 되긴 하는데 안전하게 2차원 배열은 1000 * 1000이 최대인듯?
- 따라서, dp[i] : i만큼 돈 썼을 때 최대 칼로리라고 수정

------------------------------------------

두 번째 : 87% 틀림
- dp[i] : i만큼 돈 썼을 때 최대 칼로리
- knap-sack으로 현재 사탕 선택 가능하면 dp 연산 진행

- 틀린 원인
- 사용자의 돈 money = (int)(m * 100.0), 사탕 가격 p = (int)(p * 100.0)으로 했음
- 근데 부동 소수점 문제 때문에 (m * 100 + 0.5)로 해야 된다고 함
- 실제 5.20 => 5.1999999xxx 여서 그냥 하면 519가 되버림

------------------------------------------

성공 (챗지피티) : 432ms
- * 100.0 하는 과정 수정하니까 성공

------------------------------------------

최적화 (다른 사람) : 192ms
- Knap-sack 진행할 때 현재 사용 가능한 돈을 1 ~ money까지 순회했는데
- 현재 사탕의 가격 ~ money까지 순회하니 반복 횟수 줄어듦

------------------------------------------

총평
- Knapsack 로직은 쉬웠음
- 소수 -> 정수로 변환할 때에는 (x * 100 + 0.5)로 해야 안전하다!!!!

*/

#include <bits/stdc++.h>

using namespace std;

int n; // 사탕 종류
double m; // 돈 양

int money;

pair<int, int> candy[5001]; // <칼로리, 가격>

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    while(true)
    {
        cin >> n >> m;

        if(n == 0) break;

        money = (int)(m * 100 + 0.5);

        for(int i = 1; i <= n; i++)
        {
            int c;
            double p;

            cin >> c >> p;

            candy[i] = {c, (int)(p * 100 + 0.5)};
        }

        // dp[i] : i만큼 돈 썼을 떄 최대 칼로리
        int dp[10001]; 
        memset(dp, 0, sizeof(dp));

        // 사탕 전체 순회
        for(int i = 1; i <= n; i++)
        {
            auto [curC, curP] = candy[i];

            // 현재 쓸 수 있는 돈이 j일 때
            for(int j = curP; j <= money; j++)
            {
                dp[j] = max(dp[j], dp[j - curP] + curC);
            }
        }

        int ans = 0;

        for(int i = 1; i <= money; i++) ans = max(ans, dp[i]);
        
        cout << ans << "\n";
    }

    return 0;
}