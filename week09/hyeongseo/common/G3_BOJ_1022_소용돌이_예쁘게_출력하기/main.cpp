// https://www.acmicpc.net/problem/1022

// 분류 : 수학, 구현

// 성공 : 수학, 구현

/*
성공 : 0ms

처음에 직접 소용돌이 돌며 모든 배열의 값 저장 후 그 부분만 출력하면 되겠다고 생각함
- -5000 ~ 5000 : 배열 크기 1만 * 1만 => 1억 불가능

따라서, 막무가내로 넣기 보다는 현재 좌표값을 보고 들어갈 값을 유추(계산)할 수 있어야 한다고 생각함
=> 규칙 찾기

표를 그려보니, 어느 정도의 규칙을 찾을 수 있었음

실제로, 예제를 보면 소용돌이의 구간이 나눠져있음
(0, 0) ~ (0, 0)
(-1, -1) ~ (1, 1)
(-2 , -2) ~ (2, 2)
...

따라서, 현재 좌표가 이 구간 중 어느 구간에 속해있는지 알 수 있어야 함
How?) x, y의 절댓값 중 더 큰 값이 구간 번호라고 생각함!

예) 현재 위치 : (2, -3) => (-3, -3) ~ (3, 3) 구간에 속해있구나!
예) 현재 위치 : (-1, 2) => (-2, -2) ~ (2, 2) 구간에 속해있구나!

--------------------------------------------------------------------------------

속해있는 구간을 구했다면, 이미 존재하는 어떤 값을 '기준점'으로 잡아서 현재 좌표의 값을 계산할 수 있어야 함!
How?) 기준점 => 좌상단 좌표

- 좌상단 좌표는 실제로 구할 수 있는 값임 (표 직접 그려보면 알 수 있음)
예) (-2, -2) ~ (2, 2) 구간의 좌상단 좌표 : (-2, -2)
그 곳의 값 => (-2 * 2) * (-2 * 2) + 1 => 17

예) (-3, -3) ~ (3, 3) 구간의 좌상단 좌표 : (-3, -3)
그 곳의 값 => (-3 * 2) * (-3 * 2) + 1 => 37


---------------------------------------------------------------------------------

기준점의 값을 구했다면 소용돌이를 차례대로 돌았을 때, 
- 기준점보다 이전에 도착하는지, 
- 이후에 도착하는지

구할 수 있어야 함

- 이전에 도착한다면 : 기준점 - |기준점 - 현재 위치|
- 이후에 도착한다면 : 기준점 + |기준점 + 현재 위치|

공백은 알아서 구하면 끝!

---------------------------------------------------------------------------------

총평
- 입력 값의 범위를 보고 바로 직접 소용돌이를 돌겠다는 생각을 버린 게 풀 수 있었던 핵심이었음!
- 막무가내가 아니라 규칙이 있을 것이라고 예상하고 '규칙 찾기'에 집중해서 나쁘지 않게 풀 수 있었음

*/

#include <bits/stdc++.h>

using namespace std;

int r1, c1, r2, c2;

// 정답 배열 크기 : (|r2 - r1| + 1) * (|c2 - c1| + 1)
int board[50][50];

int rSz, cSz; // 정답 배열의 행, 열 크기

int maxLen = -1; // 정답 배열에 있는 수 중 가장 큰 수의 길이

// 현재 수의 길이 구하기
int getNumLen(int num)
{
    int len = 0;

    while(num > 0)
    {
        num /= 10;
        len++;
    }

    return len;
}

// 보정 전 좌표 (x, y)를 보고 정답 배열의 삽입할 값 리턴
int getCurVal(int x, int y)
{
    // 현재 (x, y)가 어느 구간에 있는지 구하기
    int pos = max(abs(x), abs(y));

    // (x, y)는 (minX, minY) ~ (maxX, maxX) 사이에 위치 하고 있음

    // 현재 위치가 속해있는 구간의 좌상단 좌표
    int minX = pos * -1;
    int minY = pos * -1;
    
    // 현재 위치가 속해있는 구간의 우하단 좌표
    int maxX = pos;
    int maxY = pos;

    // 현재 구간의 좌상단 좌표의 값
    int topVal = (maxX * 2) * (maxX * 2) + 1;

    // 좌상단 좌표 ~ 현재 위치까지의 step 수 구하기
    int val = abs(minX - x) + abs(minY - y);

    int ret = 0;

    // 좌상단 좌표 > 현재 위치 (이전일 때)
    if((y == maxY && x != maxX) || x == minX) ret = topVal - val;

    // 좌상단 좌표 < 현재 위치 (이후일 때)
    else if(y == minY || x == maxX) ret = topVal + val;

    // cout << "(" << x << " " << y << ")는 (" << minX << " " << minY << ") ~ (" << maxX << " " << maxY << ")사이에 있고 " << minVal << " ~ " << maxVal << " 사잇값임 리턴 값: " << ret << "\n";

    return ret;
    
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> r1 >> c1 >> r2 >> c2;

    // 정답 배열 행, 열 크기 구하기
    rSz = abs(r2 - r1) + 1;
    cSz = abs(c2 - c1) + 1;

    // 일단 각 칸에 해당 하는 값을 board에 저장
    for(int i = 0; i < rSz; i++)
    {
        for(int j = 0; j < cSz; j++)
        {
            board[i][j] = getCurVal(r1 + i, c1 + j);
            maxLen = max(maxLen, getNumLen(board[i][j])); // 가장 긴 숫자 길이 업데이트
        }
    }

    // 정답 출력
    for(int i = 0; i < rSz; i++)
    {
        for(int j = 0; j < cSz; j++)
        {
            int curLen = getNumLen(board[i][j]);

            // 가장 긴 숫자 길이 맞춰서 공백 추가
            for(int k = curLen; k < maxLen; k++)
            {
                cout << " ";
            }
            cout << board[i][j] << " ";
        }
        cout << "\n";
    }

    return 0;
}