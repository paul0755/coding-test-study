// https://www.acmicpc.net/problem/3020

// 분류: 이분 탐색, 누적합, 차분 배열 트릭
// 성공 : 누적합
// 분류 보고 성공

/*
처음 접근 방법
- 범위가 50만 * 20만이기 때문에 완탐 불가능
- 따라서 이분 탐색 (매개 변수 탐색)으로 진행해야겠다 판단

Why? 부숴야하는 "최소" 개수 => 이 때까지 최대, 최소 있으면 무조건 매개변수 탐색으로 풀었음

But, 근데 생각보다 매개 변수 탐색 판별 메서드가 설계가 안됐음, 그리고 계속 헷갈렸음
=> 현재 높이에서 부술 수 있는 개수가 x개인가?
=> x개를 부술 수 있을 때 현재 높이에서 끝까지 도달 가능한가??
=> 뭔가 2가지 방법 모두 안 맞는 느낌

--------------------------------------------------------------------------------

생각의 전환
- 분류를 보니 매개변수 탐색 아닌 그냥 이분 탐색
- 따라서 이전에 "사냥꾼" 문제처럼 각 요소 (석순 / 종유석) 별로 파괴될 수 있는 구간을 구해보자 생각함
- 각 구간을 구하고, 가장 많이 겹치지 않는 높이?? 를 매개변수 탐색으로 구하면 되려나?? 하고 생각함

--------------------------------------------------------------------------------

이분 탐색 필요 없다고 판단 => 누적합해보자!
- 예전에 넥슨 코테였나?? 수의 범위가 클 때 누적합으로 처음, 끝만 표시해서 각 구간에 포함되는 변수의 개수?? 구하는 문제가 있었음
- 따라서, 위에서 구한 각 (석순 / 종유석)의 최소 높이, 최대 높이를 구했으니까
- 정답 배열 (각 높이별, 부술 수 있는 (석순 / 종유석)의 개수)
    - 시작 위치: +1
    - 끝 위치+1: -1
- 이러면 구할 수 있음!!

예) 1번 석순은 1 ~ 3 높이면 파괴됨, 2번 종유석은 2 ~ 5 구간이면 파괴됨
- ans[1]++, ans[4]--;
- ans[2]++, ans[6]--;
=> ans: 1, 1, 0, -1, 0, -1

누적합
=> ans: 1, 2, 2, 1, 1, 0
=> 이러면 높이 1, 4, 5에서는 1개의 (석순 / 종유석)만 파괴되는 걸 알 수 있음!!

---------------------------------------------------------------------------------

마무리
- 최소 파괴 개수를 구했다면, ans를 순회하며 최소 파괴 개수와 같은 높이 개수를 구한 후 출력하면 끝!!

---------------------------------------------------------------------------------

총평
- 만약 분류를 보지 않고, 계속 "매개 변수 탐색", "이분 탐색"으로 시도했다면 절대 못 풀었을 듯!!
- 다른 애들은 이분 탐색으로 어떻게 풀었는지 물어보기
- 다행히, 이전에 풀었던 문제에서 인사이트를 얻어서 다른 방법으로의 전환을 할 수 있었던 것 같음!
- 푼 문제도 다시 보자...!

63분
*/

#include <bits/stdc++.h>

using namespace std;

int n, h;

int cave[200002]; // 각 석순 / 종유석 높이

int ans[500001]; // 각 높이별 부수는 (석순 / 종유석) 개수

pair<int, int> destroyH[200002]; // 각 석순 / 종유석이 파괴되는 높이 구간

// 각 석순 / 종유석 별 파괴될 수 있는 높이 구간 구하기
void updateDestroyH(int idx, int cur)
{
    int minH = 0;
    int maxH = 0;

    // 석순 (땅에서 솟아남)
    if(idx % 2 == 1)
    {
        minH = 1;
        maxH = cur;
    }

    // 종유석 (천장에서 내려옴)
    else
    {
        maxH = h;
        minH = (h - cur) + 1;
    }

    destroyH[idx] = {minH, maxH};

}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> h;

    for(int i = 1; i <= n; i++)
    {
        cin >> cave[i];
    }

    for(int i = 1; i <= n; i++)
    {
        int cur = cave[i];
        updateDestroyH(i, cur); // 각 (석순 / 종유석 별) 파괴되는 구간 구하기

        auto [minH, maxH] = destroyH[i];

        // 누적합 고려해서
        ans[minH]++; // 최소 높이: +1
        ans[maxH+1]--; // 최대 높이+1 : -1
    }

    // 누적합을 통해서 각 높이별 부술 수 있는 (석순 / 종유석) 개수 구하기
    for(int i = 2; i <= h; i++)
    {
        ans[i] += ans[i-1];
    }

    // 파괴될 수 있는 (석순 / 종유석)의 최소개수
    int minCnt = *min_element(ans+1, ans+h+1);

    // 높이 구간 구하기
    int minRange = 0;
    for(int i = 1; i <= h; i++)
    {
        if(ans[i] == minCnt) minRange++;
    }

    cout << minCnt << " " << minRange << "\n";

    return 0;
}