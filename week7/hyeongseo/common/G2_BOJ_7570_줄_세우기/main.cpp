// https://www.acmicpc.net/problem/7570

// 분류 : DP, 그리디

// 1% 틀림 : dp (최장 증가 부분 수열)
// n - (int)dp.size();

// 1% 틀림 : dp (최장 증가 부분 수열) DP
// 무조건 인접한 부분 수열로 봄
// 이전보다 작은 값 나오면 바로 1로 만듦

// 성공 (챗지피티 & 다른 사람 풀이)
// Point!)
// 최장 증가 부분 수열인데 각 원소가 1씩 차이 나야함!
// 즉, 이동하지 않아도 될 수를 구하는 것!

// 예) 1 3 4 2 5일때
// 기존 방법 LIS : 1 3 4 5
// 새로운 방법 : 3 4 5
// 따리서, 1, 2를 옮겨야 정답!!

// 총평
// 문제 보고 LIS인 것은 알았지만 실제 정답은 살짝살짝 달랐음
// 포인트는 움직이지 않아도 될 수의 개수를 구하는 것!
// 그냥 최장 증가 부분 수열은 서로 값이 1보다 커도 적용되서 안 됐었음!
// 풀이 방법 기억해두자

#include <bits/stdc++.h>

using namespace std;

#define MAX 1000001

int n;

int dp[MAX]; // dp[i] : i가 등장했을 때 연속적인 최장 증가 부분 수열 길이

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;

    for(int i = 0; i < n; i++)
    {
        int x;
        cin >> x;

        // 이전 숫자 (1 작은 값)가 나온 적이 없다면 1이 되고
        // 이전 숫자 (1 작은 값)가 나온 적이 있따면 연속 최장 증가 부분 수열 길이 업데이트
        dp[x] = dp[x-1] + 1;
    }

    // 연속 최장 증가 부분 수열 길이 (움직일 필요 없는 숫자의 개수) 업데이트
    int ans = *max_element(dp + 1, dp + n + 1);

    cout << n - ans << "\n";

    return 0;
}