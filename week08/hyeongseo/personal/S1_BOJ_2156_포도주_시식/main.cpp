// https://www.acmicpc.net/problem/2156

/*

분류 : DP

첫 시도 : 실패
- wine[i] : i번째 포도주 양
- dp[i][j] : i번째 포도주까지 j번 연속으로 마셨을때 마신 최대 포도주 양
- dp[i][1] = max(dp[i-2][1], dp[i-2][2]) + wine[i]
- dp[i][2] = dp[i-1][1] + wine[i]
- dp 진행 중 ans = max({ans, dp[i][1], dp[i][2]});

=> 이 방법의 문제점은 포도주를 무조건 먹는 경우만 있음
따라서, dp[i][0] 또한 계산해 해당 포도주를 건너 뛰는 경우를 고려해야 함!

------------------------------------------------------------

두 번째 시도 : 실패
- dp[i][0] = max({dp[i-1][0], dp[i-1][1], dp[i-1][2]});
- dp[i][1] = max(dp[i-2][1], dp[i-2][2]}) + wine[i];
- dp[i][2] = dp[i-1][1] + wine[i];

=> 이렇게 풀었는데 또 틀림

문제점 : dp[i][1] = max(dp[i-2][1], dp[i-2][2]}) + wine[i];
이 부분에서 dp[i-2][0]인 두 번째 이전 포도주를 안 마셨을 때 상황을 고려해야 함!

------------------------------------------------------------

세 번째 시도 : 성공 (챗지피티)
- dp[i][0] = max({dp[i-1][0], dp[i-1][1], dp[i-1][2]});
- dp[i][1] = dp[i-1][0] + wine[i];
- dp[i][2] = dp[i-1][1] + wine[i];

------------------------------------------------------------

총평
- 현재 포도주를 안 먹는 경우를 놓친 게 컸던 것 같음
- 이 사실을 알고도 dp 계산할 때 한 끗차이로 못 풀었었음
- 상당히 아쉽;;
- dp 풀 때 배열 고려 시 필요한 정보 및 상황 잘 숙지하기!!
*/

#include <bits/stdc++.h>

using namespace std;

int n;

int wine[10001];

int dp[10001][3]; // dp[i][j] : i번째 포도주까지 j번 연속으로 마셨을 때 마신 최대 포도주 양

int ans = 0;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;

    for(int i = 1; i <= n; i++)
    {
        cin >> wine[i];
    }

    dp[1][1] = wine[1];

    for(int i = 2; i <= n; i++)
    {
        dp[i][0] = max({dp[i-1][0], dp[i-1][1], dp[i-1][2]}); // 현재 포도주 안 마시면 이전 포도주 상황에서의 최댓값으로 업데이트
        dp[i][1] = dp[i-1][0] + wine[i]; // 현재 포도주가 처음이면 이전 포도주 안 마신 상황 + 현재 포도주 양으로 업데이트
        dp[i][2] = dp[i-1][1] + wine[i]; // 현재 포도주가 두 번째면 이전 포도주 마신 상황 + 현재 포도주 양으로 업데이트

        // cout << "dp[" << i << "][0]: " << dp[i][0] << "\n";
        // cout << "dp[" << i << "][1]: " << dp[i][1] << "\n";
        // cout << "dp[" << i << "][2]: " << dp[i][2] << "\n";
        // cout << "======================\n";
    }

    ans = max({dp[n][0], dp[n][1], dp[n][2]});

    // cout << dp[n][0] << " " <<  dp[n][1] << " " << dp[n][2] << "\n";

    cout << ans << "\n";

    return 0;
}